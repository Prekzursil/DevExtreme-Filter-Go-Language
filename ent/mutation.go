// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"transaction-filter-backend/ent/predicate"
	"transaction-filter-backend/ent/test1schema"
	"transaction-filter-backend/ent/test2schema"
	"transaction-filter-backend/ent/test3schema"
	"transaction-filter-backend/ent/transaction"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeTest1Schema = "Test1Schema"
	TypeTest2Schema = "Test2Schema"
	TypeTest3Schema = "Test3Schema"
	TypeTransaction = "Transaction"
)

// Test1SchemaMutation represents an operation that mutates the Test1Schema nodes in the graph.
type Test1SchemaMutation struct {
	config
	op             Op
	typ            string
	id             *int
	field_string   *string
	field_int      *int
	addfield_int   *int
	field_float    *float64
	addfield_float *float64
	field_bool     *bool
	field_time     *time.Time
	field_text     *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Test1Schema, error)
	predicates     []predicate.Test1Schema
}

var _ ent.Mutation = (*Test1SchemaMutation)(nil)

// test1schemaOption allows management of the mutation configuration using functional options.
type test1schemaOption func(*Test1SchemaMutation)

// newTest1SchemaMutation creates new mutation for the Test1Schema entity.
func newTest1SchemaMutation(c config, op Op, opts ...test1schemaOption) *Test1SchemaMutation {
	m := &Test1SchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeTest1Schema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTest1SchemaID sets the ID field of the mutation.
func withTest1SchemaID(id int) test1schemaOption {
	return func(m *Test1SchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *Test1Schema
		)
		m.oldValue = func(ctx context.Context) (*Test1Schema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test1Schema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest1Schema sets the old Test1Schema of the mutation.
func withTest1Schema(node *Test1Schema) test1schemaOption {
	return func(m *Test1SchemaMutation) {
		m.oldValue = func(context.Context) (*Test1Schema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Test1SchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Test1SchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Test1SchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Test1SchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test1Schema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFieldString sets the "field_string" field.
func (m *Test1SchemaMutation) SetFieldString(s string) {
	m.field_string = &s
}

// FieldString returns the value of the "field_string" field in the mutation.
func (m *Test1SchemaMutation) FieldString() (r string, exists bool) {
	v := m.field_string
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldString returns the old "field_string" field's value of the Test1Schema entity.
// If the Test1Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test1SchemaMutation) OldFieldString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldString: %w", err)
	}
	return oldValue.FieldString, nil
}

// ResetFieldString resets all changes to the "field_string" field.
func (m *Test1SchemaMutation) ResetFieldString() {
	m.field_string = nil
}

// SetFieldInt sets the "field_int" field.
func (m *Test1SchemaMutation) SetFieldInt(i int) {
	m.field_int = &i
	m.addfield_int = nil
}

// FieldInt returns the value of the "field_int" field in the mutation.
func (m *Test1SchemaMutation) FieldInt() (r int, exists bool) {
	v := m.field_int
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldInt returns the old "field_int" field's value of the Test1Schema entity.
// If the Test1Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test1SchemaMutation) OldFieldInt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldInt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldInt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldInt: %w", err)
	}
	return oldValue.FieldInt, nil
}

// AddFieldInt adds i to the "field_int" field.
func (m *Test1SchemaMutation) AddFieldInt(i int) {
	if m.addfield_int != nil {
		*m.addfield_int += i
	} else {
		m.addfield_int = &i
	}
}

// AddedFieldInt returns the value that was added to the "field_int" field in this mutation.
func (m *Test1SchemaMutation) AddedFieldInt() (r int, exists bool) {
	v := m.addfield_int
	if v == nil {
		return
	}
	return *v, true
}

// ResetFieldInt resets all changes to the "field_int" field.
func (m *Test1SchemaMutation) ResetFieldInt() {
	m.field_int = nil
	m.addfield_int = nil
}

// SetFieldFloat sets the "field_float" field.
func (m *Test1SchemaMutation) SetFieldFloat(f float64) {
	m.field_float = &f
	m.addfield_float = nil
}

// FieldFloat returns the value of the "field_float" field in the mutation.
func (m *Test1SchemaMutation) FieldFloat() (r float64, exists bool) {
	v := m.field_float
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldFloat returns the old "field_float" field's value of the Test1Schema entity.
// If the Test1Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test1SchemaMutation) OldFieldFloat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldFloat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldFloat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldFloat: %w", err)
	}
	return oldValue.FieldFloat, nil
}

// AddFieldFloat adds f to the "field_float" field.
func (m *Test1SchemaMutation) AddFieldFloat(f float64) {
	if m.addfield_float != nil {
		*m.addfield_float += f
	} else {
		m.addfield_float = &f
	}
}

// AddedFieldFloat returns the value that was added to the "field_float" field in this mutation.
func (m *Test1SchemaMutation) AddedFieldFloat() (r float64, exists bool) {
	v := m.addfield_float
	if v == nil {
		return
	}
	return *v, true
}

// ResetFieldFloat resets all changes to the "field_float" field.
func (m *Test1SchemaMutation) ResetFieldFloat() {
	m.field_float = nil
	m.addfield_float = nil
}

// SetFieldBool sets the "field_bool" field.
func (m *Test1SchemaMutation) SetFieldBool(b bool) {
	m.field_bool = &b
}

// FieldBool returns the value of the "field_bool" field in the mutation.
func (m *Test1SchemaMutation) FieldBool() (r bool, exists bool) {
	v := m.field_bool
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldBool returns the old "field_bool" field's value of the Test1Schema entity.
// If the Test1Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test1SchemaMutation) OldFieldBool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldBool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldBool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldBool: %w", err)
	}
	return oldValue.FieldBool, nil
}

// ResetFieldBool resets all changes to the "field_bool" field.
func (m *Test1SchemaMutation) ResetFieldBool() {
	m.field_bool = nil
}

// SetFieldTime sets the "field_time" field.
func (m *Test1SchemaMutation) SetFieldTime(t time.Time) {
	m.field_time = &t
}

// FieldTime returns the value of the "field_time" field in the mutation.
func (m *Test1SchemaMutation) FieldTime() (r time.Time, exists bool) {
	v := m.field_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldTime returns the old "field_time" field's value of the Test1Schema entity.
// If the Test1Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test1SchemaMutation) OldFieldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldTime: %w", err)
	}
	return oldValue.FieldTime, nil
}

// ResetFieldTime resets all changes to the "field_time" field.
func (m *Test1SchemaMutation) ResetFieldTime() {
	m.field_time = nil
}

// SetFieldText sets the "field_text" field.
func (m *Test1SchemaMutation) SetFieldText(s string) {
	m.field_text = &s
}

// FieldText returns the value of the "field_text" field in the mutation.
func (m *Test1SchemaMutation) FieldText() (r string, exists bool) {
	v := m.field_text
	if v == nil {
		return
	}
	return *v, true
}

// OldFieldText returns the old "field_text" field's value of the Test1Schema entity.
// If the Test1Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test1SchemaMutation) OldFieldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFieldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFieldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFieldText: %w", err)
	}
	return oldValue.FieldText, nil
}

// ClearFieldText clears the value of the "field_text" field.
func (m *Test1SchemaMutation) ClearFieldText() {
	m.field_text = nil
	m.clearedFields[test1schema.FieldFieldText] = struct{}{}
}

// FieldTextCleared returns if the "field_text" field was cleared in this mutation.
func (m *Test1SchemaMutation) FieldTextCleared() bool {
	_, ok := m.clearedFields[test1schema.FieldFieldText]
	return ok
}

// ResetFieldText resets all changes to the "field_text" field.
func (m *Test1SchemaMutation) ResetFieldText() {
	m.field_text = nil
	delete(m.clearedFields, test1schema.FieldFieldText)
}

// Where appends a list predicates to the Test1SchemaMutation builder.
func (m *Test1SchemaMutation) Where(ps ...predicate.Test1Schema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Test1SchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Test1SchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test1Schema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Test1SchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Test1SchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test1Schema).
func (m *Test1SchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Test1SchemaMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.field_string != nil {
		fields = append(fields, test1schema.FieldFieldString)
	}
	if m.field_int != nil {
		fields = append(fields, test1schema.FieldFieldInt)
	}
	if m.field_float != nil {
		fields = append(fields, test1schema.FieldFieldFloat)
	}
	if m.field_bool != nil {
		fields = append(fields, test1schema.FieldFieldBool)
	}
	if m.field_time != nil {
		fields = append(fields, test1schema.FieldFieldTime)
	}
	if m.field_text != nil {
		fields = append(fields, test1schema.FieldFieldText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Test1SchemaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test1schema.FieldFieldString:
		return m.FieldString()
	case test1schema.FieldFieldInt:
		return m.FieldInt()
	case test1schema.FieldFieldFloat:
		return m.FieldFloat()
	case test1schema.FieldFieldBool:
		return m.FieldBool()
	case test1schema.FieldFieldTime:
		return m.FieldTime()
	case test1schema.FieldFieldText:
		return m.FieldText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Test1SchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test1schema.FieldFieldString:
		return m.OldFieldString(ctx)
	case test1schema.FieldFieldInt:
		return m.OldFieldInt(ctx)
	case test1schema.FieldFieldFloat:
		return m.OldFieldFloat(ctx)
	case test1schema.FieldFieldBool:
		return m.OldFieldBool(ctx)
	case test1schema.FieldFieldTime:
		return m.OldFieldTime(ctx)
	case test1schema.FieldFieldText:
		return m.OldFieldText(ctx)
	}
	return nil, fmt.Errorf("unknown Test1Schema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Test1SchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test1schema.FieldFieldString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldString(v)
		return nil
	case test1schema.FieldFieldInt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldInt(v)
		return nil
	case test1schema.FieldFieldFloat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldFloat(v)
		return nil
	case test1schema.FieldFieldBool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldBool(v)
		return nil
	case test1schema.FieldFieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldTime(v)
		return nil
	case test1schema.FieldFieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFieldText(v)
		return nil
	}
	return fmt.Errorf("unknown Test1Schema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Test1SchemaMutation) AddedFields() []string {
	var fields []string
	if m.addfield_int != nil {
		fields = append(fields, test1schema.FieldFieldInt)
	}
	if m.addfield_float != nil {
		fields = append(fields, test1schema.FieldFieldFloat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Test1SchemaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case test1schema.FieldFieldInt:
		return m.AddedFieldInt()
	case test1schema.FieldFieldFloat:
		return m.AddedFieldFloat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Test1SchemaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case test1schema.FieldFieldInt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFieldInt(v)
		return nil
	case test1schema.FieldFieldFloat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFieldFloat(v)
		return nil
	}
	return fmt.Errorf("unknown Test1Schema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Test1SchemaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(test1schema.FieldFieldText) {
		fields = append(fields, test1schema.FieldFieldText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Test1SchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Test1SchemaMutation) ClearField(name string) error {
	switch name {
	case test1schema.FieldFieldText:
		m.ClearFieldText()
		return nil
	}
	return fmt.Errorf("unknown Test1Schema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Test1SchemaMutation) ResetField(name string) error {
	switch name {
	case test1schema.FieldFieldString:
		m.ResetFieldString()
		return nil
	case test1schema.FieldFieldInt:
		m.ResetFieldInt()
		return nil
	case test1schema.FieldFieldFloat:
		m.ResetFieldFloat()
		return nil
	case test1schema.FieldFieldBool:
		m.ResetFieldBool()
		return nil
	case test1schema.FieldFieldTime:
		m.ResetFieldTime()
		return nil
	case test1schema.FieldFieldText:
		m.ResetFieldText()
		return nil
	}
	return fmt.Errorf("unknown Test1Schema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Test1SchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Test1SchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Test1SchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Test1SchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Test1SchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Test1SchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Test1SchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test1Schema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Test1SchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test1Schema edge %s", name)
}

// Test2SchemaMutation represents an operation that mutates the Test2Schema nodes in the graph.
type Test2SchemaMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	description   *string
	quantity      *int
	addquantity   *int
	price         *float64
	addprice      *float64
	active        *bool
	created_at    *time.Time
	updated_at    *time.Time
	item_type     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Test2Schema, error)
	predicates    []predicate.Test2Schema
}

var _ ent.Mutation = (*Test2SchemaMutation)(nil)

// test2schemaOption allows management of the mutation configuration using functional options.
type test2schemaOption func(*Test2SchemaMutation)

// newTest2SchemaMutation creates new mutation for the Test2Schema entity.
func newTest2SchemaMutation(c config, op Op, opts ...test2schemaOption) *Test2SchemaMutation {
	m := &Test2SchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeTest2Schema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTest2SchemaID sets the ID field of the mutation.
func withTest2SchemaID(id int) test2schemaOption {
	return func(m *Test2SchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *Test2Schema
		)
		m.oldValue = func(ctx context.Context) (*Test2Schema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test2Schema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest2Schema sets the old Test2Schema of the mutation.
func withTest2Schema(node *Test2Schema) test2schemaOption {
	return func(m *Test2SchemaMutation) {
		m.oldValue = func(context.Context) (*Test2Schema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Test2SchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Test2SchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Test2SchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Test2SchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test2Schema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *Test2SchemaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *Test2SchemaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *Test2SchemaMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *Test2SchemaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *Test2SchemaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *Test2SchemaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[test2schema.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *Test2SchemaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[test2schema.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *Test2SchemaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, test2schema.FieldDescription)
}

// SetQuantity sets the "quantity" field.
func (m *Test2SchemaMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *Test2SchemaMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *Test2SchemaMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *Test2SchemaMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *Test2SchemaMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
}

// SetPrice sets the "price" field.
func (m *Test2SchemaMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *Test2SchemaMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *Test2SchemaMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *Test2SchemaMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *Test2SchemaMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetActive sets the "active" field.
func (m *Test2SchemaMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *Test2SchemaMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *Test2SchemaMutation) ResetActive() {
	m.active = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *Test2SchemaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *Test2SchemaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *Test2SchemaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *Test2SchemaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *Test2SchemaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *Test2SchemaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetItemType sets the "item_type" field.
func (m *Test2SchemaMutation) SetItemType(s string) {
	m.item_type = &s
}

// ItemType returns the value of the "item_type" field in the mutation.
func (m *Test2SchemaMutation) ItemType() (r string, exists bool) {
	v := m.item_type
	if v == nil {
		return
	}
	return *v, true
}

// OldItemType returns the old "item_type" field's value of the Test2Schema entity.
// If the Test2Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test2SchemaMutation) OldItemType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemType: %w", err)
	}
	return oldValue.ItemType, nil
}

// ClearItemType clears the value of the "item_type" field.
func (m *Test2SchemaMutation) ClearItemType() {
	m.item_type = nil
	m.clearedFields[test2schema.FieldItemType] = struct{}{}
}

// ItemTypeCleared returns if the "item_type" field was cleared in this mutation.
func (m *Test2SchemaMutation) ItemTypeCleared() bool {
	_, ok := m.clearedFields[test2schema.FieldItemType]
	return ok
}

// ResetItemType resets all changes to the "item_type" field.
func (m *Test2SchemaMutation) ResetItemType() {
	m.item_type = nil
	delete(m.clearedFields, test2schema.FieldItemType)
}

// Where appends a list predicates to the Test2SchemaMutation builder.
func (m *Test2SchemaMutation) Where(ps ...predicate.Test2Schema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Test2SchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Test2SchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test2Schema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Test2SchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Test2SchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test2Schema).
func (m *Test2SchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Test2SchemaMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, test2schema.FieldName)
	}
	if m.description != nil {
		fields = append(fields, test2schema.FieldDescription)
	}
	if m.quantity != nil {
		fields = append(fields, test2schema.FieldQuantity)
	}
	if m.price != nil {
		fields = append(fields, test2schema.FieldPrice)
	}
	if m.active != nil {
		fields = append(fields, test2schema.FieldActive)
	}
	if m.created_at != nil {
		fields = append(fields, test2schema.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, test2schema.FieldUpdatedAt)
	}
	if m.item_type != nil {
		fields = append(fields, test2schema.FieldItemType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Test2SchemaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test2schema.FieldName:
		return m.Name()
	case test2schema.FieldDescription:
		return m.Description()
	case test2schema.FieldQuantity:
		return m.Quantity()
	case test2schema.FieldPrice:
		return m.Price()
	case test2schema.FieldActive:
		return m.Active()
	case test2schema.FieldCreatedAt:
		return m.CreatedAt()
	case test2schema.FieldUpdatedAt:
		return m.UpdatedAt()
	case test2schema.FieldItemType:
		return m.ItemType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Test2SchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test2schema.FieldName:
		return m.OldName(ctx)
	case test2schema.FieldDescription:
		return m.OldDescription(ctx)
	case test2schema.FieldQuantity:
		return m.OldQuantity(ctx)
	case test2schema.FieldPrice:
		return m.OldPrice(ctx)
	case test2schema.FieldActive:
		return m.OldActive(ctx)
	case test2schema.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case test2schema.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case test2schema.FieldItemType:
		return m.OldItemType(ctx)
	}
	return nil, fmt.Errorf("unknown Test2Schema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Test2SchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test2schema.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case test2schema.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case test2schema.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case test2schema.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case test2schema.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case test2schema.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case test2schema.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case test2schema.FieldItemType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemType(v)
		return nil
	}
	return fmt.Errorf("unknown Test2Schema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Test2SchemaMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, test2schema.FieldQuantity)
	}
	if m.addprice != nil {
		fields = append(fields, test2schema.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Test2SchemaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case test2schema.FieldQuantity:
		return m.AddedQuantity()
	case test2schema.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Test2SchemaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case test2schema.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case test2schema.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Test2Schema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Test2SchemaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(test2schema.FieldDescription) {
		fields = append(fields, test2schema.FieldDescription)
	}
	if m.FieldCleared(test2schema.FieldItemType) {
		fields = append(fields, test2schema.FieldItemType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Test2SchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Test2SchemaMutation) ClearField(name string) error {
	switch name {
	case test2schema.FieldDescription:
		m.ClearDescription()
		return nil
	case test2schema.FieldItemType:
		m.ClearItemType()
		return nil
	}
	return fmt.Errorf("unknown Test2Schema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Test2SchemaMutation) ResetField(name string) error {
	switch name {
	case test2schema.FieldName:
		m.ResetName()
		return nil
	case test2schema.FieldDescription:
		m.ResetDescription()
		return nil
	case test2schema.FieldQuantity:
		m.ResetQuantity()
		return nil
	case test2schema.FieldPrice:
		m.ResetPrice()
		return nil
	case test2schema.FieldActive:
		m.ResetActive()
		return nil
	case test2schema.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case test2schema.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case test2schema.FieldItemType:
		m.ResetItemType()
		return nil
	}
	return fmt.Errorf("unknown Test2Schema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Test2SchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Test2SchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Test2SchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Test2SchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Test2SchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Test2SchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Test2SchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test2Schema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Test2SchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test2Schema edge %s", name)
}

// Test3SchemaMutation represents an operation that mutates the Test3Schema nodes in the graph.
type Test3SchemaMutation struct {
	config
	op                Op
	typ               string
	id                *int
	sku               *string
	product_name      *string
	short_description *string
	full_description  *string
	cost_price        *float64
	addcost_price     *float64
	retail_price      *float64
	addretail_price   *float64
	stock_count       *int
	addstock_count    *int
	is_active         *bool
	published_at      *time.Time
	last_ordered_at   *time.Time
	tags              *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Test3Schema, error)
	predicates        []predicate.Test3Schema
}

var _ ent.Mutation = (*Test3SchemaMutation)(nil)

// test3schemaOption allows management of the mutation configuration using functional options.
type test3schemaOption func(*Test3SchemaMutation)

// newTest3SchemaMutation creates new mutation for the Test3Schema entity.
func newTest3SchemaMutation(c config, op Op, opts ...test3schemaOption) *Test3SchemaMutation {
	m := &Test3SchemaMutation{
		config:        c,
		op:            op,
		typ:           TypeTest3Schema,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTest3SchemaID sets the ID field of the mutation.
func withTest3SchemaID(id int) test3schemaOption {
	return func(m *Test3SchemaMutation) {
		var (
			err   error
			once  sync.Once
			value *Test3Schema
		)
		m.oldValue = func(ctx context.Context) (*Test3Schema, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Test3Schema.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTest3Schema sets the old Test3Schema of the mutation.
func withTest3Schema(node *Test3Schema) test3schemaOption {
	return func(m *Test3SchemaMutation) {
		m.oldValue = func(context.Context) (*Test3Schema, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m Test3SchemaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m Test3SchemaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *Test3SchemaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *Test3SchemaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Test3Schema.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSku sets the "sku" field.
func (m *Test3SchemaMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *Test3SchemaMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldSku(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ResetSku resets all changes to the "sku" field.
func (m *Test3SchemaMutation) ResetSku() {
	m.sku = nil
}

// SetProductName sets the "product_name" field.
func (m *Test3SchemaMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *Test3SchemaMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *Test3SchemaMutation) ResetProductName() {
	m.product_name = nil
}

// SetShortDescription sets the "short_description" field.
func (m *Test3SchemaMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *Test3SchemaMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *Test3SchemaMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[test3schema.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *Test3SchemaMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[test3schema.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *Test3SchemaMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, test3schema.FieldShortDescription)
}

// SetFullDescription sets the "full_description" field.
func (m *Test3SchemaMutation) SetFullDescription(s string) {
	m.full_description = &s
}

// FullDescription returns the value of the "full_description" field in the mutation.
func (m *Test3SchemaMutation) FullDescription() (r string, exists bool) {
	v := m.full_description
	if v == nil {
		return
	}
	return *v, true
}

// OldFullDescription returns the old "full_description" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldFullDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullDescription: %w", err)
	}
	return oldValue.FullDescription, nil
}

// ClearFullDescription clears the value of the "full_description" field.
func (m *Test3SchemaMutation) ClearFullDescription() {
	m.full_description = nil
	m.clearedFields[test3schema.FieldFullDescription] = struct{}{}
}

// FullDescriptionCleared returns if the "full_description" field was cleared in this mutation.
func (m *Test3SchemaMutation) FullDescriptionCleared() bool {
	_, ok := m.clearedFields[test3schema.FieldFullDescription]
	return ok
}

// ResetFullDescription resets all changes to the "full_description" field.
func (m *Test3SchemaMutation) ResetFullDescription() {
	m.full_description = nil
	delete(m.clearedFields, test3schema.FieldFullDescription)
}

// SetCostPrice sets the "cost_price" field.
func (m *Test3SchemaMutation) SetCostPrice(f float64) {
	m.cost_price = &f
	m.addcost_price = nil
}

// CostPrice returns the value of the "cost_price" field in the mutation.
func (m *Test3SchemaMutation) CostPrice() (r float64, exists bool) {
	v := m.cost_price
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPrice returns the old "cost_price" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldCostPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPrice: %w", err)
	}
	return oldValue.CostPrice, nil
}

// AddCostPrice adds f to the "cost_price" field.
func (m *Test3SchemaMutation) AddCostPrice(f float64) {
	if m.addcost_price != nil {
		*m.addcost_price += f
	} else {
		m.addcost_price = &f
	}
}

// AddedCostPrice returns the value that was added to the "cost_price" field in this mutation.
func (m *Test3SchemaMutation) AddedCostPrice() (r float64, exists bool) {
	v := m.addcost_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetCostPrice resets all changes to the "cost_price" field.
func (m *Test3SchemaMutation) ResetCostPrice() {
	m.cost_price = nil
	m.addcost_price = nil
}

// SetRetailPrice sets the "retail_price" field.
func (m *Test3SchemaMutation) SetRetailPrice(f float64) {
	m.retail_price = &f
	m.addretail_price = nil
}

// RetailPrice returns the value of the "retail_price" field in the mutation.
func (m *Test3SchemaMutation) RetailPrice() (r float64, exists bool) {
	v := m.retail_price
	if v == nil {
		return
	}
	return *v, true
}

// OldRetailPrice returns the old "retail_price" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldRetailPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetailPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetailPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetailPrice: %w", err)
	}
	return oldValue.RetailPrice, nil
}

// AddRetailPrice adds f to the "retail_price" field.
func (m *Test3SchemaMutation) AddRetailPrice(f float64) {
	if m.addretail_price != nil {
		*m.addretail_price += f
	} else {
		m.addretail_price = &f
	}
}

// AddedRetailPrice returns the value that was added to the "retail_price" field in this mutation.
func (m *Test3SchemaMutation) AddedRetailPrice() (r float64, exists bool) {
	v := m.addretail_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetailPrice resets all changes to the "retail_price" field.
func (m *Test3SchemaMutation) ResetRetailPrice() {
	m.retail_price = nil
	m.addretail_price = nil
}

// SetStockCount sets the "stock_count" field.
func (m *Test3SchemaMutation) SetStockCount(i int) {
	m.stock_count = &i
	m.addstock_count = nil
}

// StockCount returns the value of the "stock_count" field in the mutation.
func (m *Test3SchemaMutation) StockCount() (r int, exists bool) {
	v := m.stock_count
	if v == nil {
		return
	}
	return *v, true
}

// OldStockCount returns the old "stock_count" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldStockCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockCount: %w", err)
	}
	return oldValue.StockCount, nil
}

// AddStockCount adds i to the "stock_count" field.
func (m *Test3SchemaMutation) AddStockCount(i int) {
	if m.addstock_count != nil {
		*m.addstock_count += i
	} else {
		m.addstock_count = &i
	}
}

// AddedStockCount returns the value that was added to the "stock_count" field in this mutation.
func (m *Test3SchemaMutation) AddedStockCount() (r int, exists bool) {
	v := m.addstock_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockCount resets all changes to the "stock_count" field.
func (m *Test3SchemaMutation) ResetStockCount() {
	m.stock_count = nil
	m.addstock_count = nil
}

// SetIsActive sets the "is_active" field.
func (m *Test3SchemaMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *Test3SchemaMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *Test3SchemaMutation) ResetIsActive() {
	m.is_active = nil
}

// SetPublishedAt sets the "published_at" field.
func (m *Test3SchemaMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the value of the "published_at" field in the mutation.
func (m *Test3SchemaMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedAt returns the old "published_at" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldPublishedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedAt: %w", err)
	}
	return oldValue.PublishedAt, nil
}

// ClearPublishedAt clears the value of the "published_at" field.
func (m *Test3SchemaMutation) ClearPublishedAt() {
	m.published_at = nil
	m.clearedFields[test3schema.FieldPublishedAt] = struct{}{}
}

// PublishedAtCleared returns if the "published_at" field was cleared in this mutation.
func (m *Test3SchemaMutation) PublishedAtCleared() bool {
	_, ok := m.clearedFields[test3schema.FieldPublishedAt]
	return ok
}

// ResetPublishedAt resets all changes to the "published_at" field.
func (m *Test3SchemaMutation) ResetPublishedAt() {
	m.published_at = nil
	delete(m.clearedFields, test3schema.FieldPublishedAt)
}

// SetLastOrderedAt sets the "last_ordered_at" field.
func (m *Test3SchemaMutation) SetLastOrderedAt(t time.Time) {
	m.last_ordered_at = &t
}

// LastOrderedAt returns the value of the "last_ordered_at" field in the mutation.
func (m *Test3SchemaMutation) LastOrderedAt() (r time.Time, exists bool) {
	v := m.last_ordered_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastOrderedAt returns the old "last_ordered_at" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldLastOrderedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastOrderedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastOrderedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastOrderedAt: %w", err)
	}
	return oldValue.LastOrderedAt, nil
}

// ClearLastOrderedAt clears the value of the "last_ordered_at" field.
func (m *Test3SchemaMutation) ClearLastOrderedAt() {
	m.last_ordered_at = nil
	m.clearedFields[test3schema.FieldLastOrderedAt] = struct{}{}
}

// LastOrderedAtCleared returns if the "last_ordered_at" field was cleared in this mutation.
func (m *Test3SchemaMutation) LastOrderedAtCleared() bool {
	_, ok := m.clearedFields[test3schema.FieldLastOrderedAt]
	return ok
}

// ResetLastOrderedAt resets all changes to the "last_ordered_at" field.
func (m *Test3SchemaMutation) ResetLastOrderedAt() {
	m.last_ordered_at = nil
	delete(m.clearedFields, test3schema.FieldLastOrderedAt)
}

// SetTags sets the "tags" field.
func (m *Test3SchemaMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *Test3SchemaMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Test3Schema entity.
// If the Test3Schema object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *Test3SchemaMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *Test3SchemaMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[test3schema.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *Test3SchemaMutation) TagsCleared() bool {
	_, ok := m.clearedFields[test3schema.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *Test3SchemaMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, test3schema.FieldTags)
}

// Where appends a list predicates to the Test3SchemaMutation builder.
func (m *Test3SchemaMutation) Where(ps ...predicate.Test3Schema) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the Test3SchemaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *Test3SchemaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Test3Schema, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *Test3SchemaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *Test3SchemaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Test3Schema).
func (m *Test3SchemaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *Test3SchemaMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.sku != nil {
		fields = append(fields, test3schema.FieldSku)
	}
	if m.product_name != nil {
		fields = append(fields, test3schema.FieldProductName)
	}
	if m.short_description != nil {
		fields = append(fields, test3schema.FieldShortDescription)
	}
	if m.full_description != nil {
		fields = append(fields, test3schema.FieldFullDescription)
	}
	if m.cost_price != nil {
		fields = append(fields, test3schema.FieldCostPrice)
	}
	if m.retail_price != nil {
		fields = append(fields, test3schema.FieldRetailPrice)
	}
	if m.stock_count != nil {
		fields = append(fields, test3schema.FieldStockCount)
	}
	if m.is_active != nil {
		fields = append(fields, test3schema.FieldIsActive)
	}
	if m.published_at != nil {
		fields = append(fields, test3schema.FieldPublishedAt)
	}
	if m.last_ordered_at != nil {
		fields = append(fields, test3schema.FieldLastOrderedAt)
	}
	if m.tags != nil {
		fields = append(fields, test3schema.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *Test3SchemaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case test3schema.FieldSku:
		return m.Sku()
	case test3schema.FieldProductName:
		return m.ProductName()
	case test3schema.FieldShortDescription:
		return m.ShortDescription()
	case test3schema.FieldFullDescription:
		return m.FullDescription()
	case test3schema.FieldCostPrice:
		return m.CostPrice()
	case test3schema.FieldRetailPrice:
		return m.RetailPrice()
	case test3schema.FieldStockCount:
		return m.StockCount()
	case test3schema.FieldIsActive:
		return m.IsActive()
	case test3schema.FieldPublishedAt:
		return m.PublishedAt()
	case test3schema.FieldLastOrderedAt:
		return m.LastOrderedAt()
	case test3schema.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *Test3SchemaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case test3schema.FieldSku:
		return m.OldSku(ctx)
	case test3schema.FieldProductName:
		return m.OldProductName(ctx)
	case test3schema.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case test3schema.FieldFullDescription:
		return m.OldFullDescription(ctx)
	case test3schema.FieldCostPrice:
		return m.OldCostPrice(ctx)
	case test3schema.FieldRetailPrice:
		return m.OldRetailPrice(ctx)
	case test3schema.FieldStockCount:
		return m.OldStockCount(ctx)
	case test3schema.FieldIsActive:
		return m.OldIsActive(ctx)
	case test3schema.FieldPublishedAt:
		return m.OldPublishedAt(ctx)
	case test3schema.FieldLastOrderedAt:
		return m.OldLastOrderedAt(ctx)
	case test3schema.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown Test3Schema field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Test3SchemaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case test3schema.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	case test3schema.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case test3schema.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case test3schema.FieldFullDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullDescription(v)
		return nil
	case test3schema.FieldCostPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPrice(v)
		return nil
	case test3schema.FieldRetailPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetailPrice(v)
		return nil
	case test3schema.FieldStockCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockCount(v)
		return nil
	case test3schema.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case test3schema.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case test3schema.FieldLastOrderedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastOrderedAt(v)
		return nil
	case test3schema.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown Test3Schema field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *Test3SchemaMutation) AddedFields() []string {
	var fields []string
	if m.addcost_price != nil {
		fields = append(fields, test3schema.FieldCostPrice)
	}
	if m.addretail_price != nil {
		fields = append(fields, test3schema.FieldRetailPrice)
	}
	if m.addstock_count != nil {
		fields = append(fields, test3schema.FieldStockCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *Test3SchemaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case test3schema.FieldCostPrice:
		return m.AddedCostPrice()
	case test3schema.FieldRetailPrice:
		return m.AddedRetailPrice()
	case test3schema.FieldStockCount:
		return m.AddedStockCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *Test3SchemaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case test3schema.FieldCostPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPrice(v)
		return nil
	case test3schema.FieldRetailPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetailPrice(v)
		return nil
	case test3schema.FieldStockCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockCount(v)
		return nil
	}
	return fmt.Errorf("unknown Test3Schema numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *Test3SchemaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(test3schema.FieldShortDescription) {
		fields = append(fields, test3schema.FieldShortDescription)
	}
	if m.FieldCleared(test3schema.FieldFullDescription) {
		fields = append(fields, test3schema.FieldFullDescription)
	}
	if m.FieldCleared(test3schema.FieldPublishedAt) {
		fields = append(fields, test3schema.FieldPublishedAt)
	}
	if m.FieldCleared(test3schema.FieldLastOrderedAt) {
		fields = append(fields, test3schema.FieldLastOrderedAt)
	}
	if m.FieldCleared(test3schema.FieldTags) {
		fields = append(fields, test3schema.FieldTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *Test3SchemaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *Test3SchemaMutation) ClearField(name string) error {
	switch name {
	case test3schema.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case test3schema.FieldFullDescription:
		m.ClearFullDescription()
		return nil
	case test3schema.FieldPublishedAt:
		m.ClearPublishedAt()
		return nil
	case test3schema.FieldLastOrderedAt:
		m.ClearLastOrderedAt()
		return nil
	case test3schema.FieldTags:
		m.ClearTags()
		return nil
	}
	return fmt.Errorf("unknown Test3Schema nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *Test3SchemaMutation) ResetField(name string) error {
	switch name {
	case test3schema.FieldSku:
		m.ResetSku()
		return nil
	case test3schema.FieldProductName:
		m.ResetProductName()
		return nil
	case test3schema.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case test3schema.FieldFullDescription:
		m.ResetFullDescription()
		return nil
	case test3schema.FieldCostPrice:
		m.ResetCostPrice()
		return nil
	case test3schema.FieldRetailPrice:
		m.ResetRetailPrice()
		return nil
	case test3schema.FieldStockCount:
		m.ResetStockCount()
		return nil
	case test3schema.FieldIsActive:
		m.ResetIsActive()
		return nil
	case test3schema.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case test3schema.FieldLastOrderedAt:
		m.ResetLastOrderedAt()
		return nil
	case test3schema.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Test3Schema field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *Test3SchemaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *Test3SchemaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *Test3SchemaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *Test3SchemaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *Test3SchemaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *Test3SchemaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *Test3SchemaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Test3Schema unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *Test3SchemaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Test3Schema edge %s", name)
}

// TransactionMutation represents an operation that mutates the Transaction nodes in the graph.
type TransactionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	date          *time.Time
	amount        *float64
	addamount     *float64
	name          *string
	location      *string
	category      *string
	_type         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Transaction, error)
	predicates    []predicate.Transaction
}

var _ ent.Mutation = (*TransactionMutation)(nil)

// transactionOption allows management of the mutation configuration using functional options.
type transactionOption func(*TransactionMutation)

// newTransactionMutation creates new mutation for the Transaction entity.
func newTransactionMutation(c config, op Op, opts ...transactionOption) *TransactionMutation {
	m := &TransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionID sets the ID field of the mutation.
func withTransactionID(id int) transactionOption {
	return func(m *TransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Transaction
		)
		m.oldValue = func(ctx context.Context) (*Transaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransaction sets the old Transaction of the mutation.
func withTransaction(node *Transaction) transactionOption {
	return func(m *TransactionMutation) {
		m.oldValue = func(context.Context) (*Transaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *TransactionMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *TransactionMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *TransactionMutation) ResetDate() {
	m.date = nil
}

// SetAmount sets the "amount" field.
func (m *TransactionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TransactionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TransactionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetName sets the "name" field.
func (m *TransactionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TransactionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TransactionMutation) ResetName() {
	m.name = nil
}

// SetLocation sets the "location" field.
func (m *TransactionMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *TransactionMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ResetLocation resets all changes to the "location" field.
func (m *TransactionMutation) ResetLocation() {
	m.location = nil
}

// SetCategory sets the "category" field.
func (m *TransactionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *TransactionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *TransactionMutation) ResetCategory() {
	m.category = nil
}

// SetType sets the "type" field.
func (m *TransactionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransactionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transaction entity.
// If the Transaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransactionMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the TransactionMutation builder.
func (m *TransactionMutation) Where(ps ...predicate.Transaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transaction).
func (m *TransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.date != nil {
		fields = append(fields, transaction.FieldDate)
	}
	if m.amount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	if m.name != nil {
		fields = append(fields, transaction.FieldName)
	}
	if m.location != nil {
		fields = append(fields, transaction.FieldLocation)
	}
	if m.category != nil {
		fields = append(fields, transaction.FieldCategory)
	}
	if m._type != nil {
		fields = append(fields, transaction.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldDate:
		return m.Date()
	case transaction.FieldAmount:
		return m.Amount()
	case transaction.FieldName:
		return m.Name()
	case transaction.FieldLocation:
		return m.Location()
	case transaction.FieldCategory:
		return m.Category()
	case transaction.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transaction.FieldDate:
		return m.OldDate(ctx)
	case transaction.FieldAmount:
		return m.OldAmount(ctx)
	case transaction.FieldName:
		return m.OldName(ctx)
	case transaction.FieldLocation:
		return m.OldLocation(ctx)
	case transaction.FieldCategory:
		return m.OldCategory(ctx)
	case transaction.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Transaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case transaction.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case transaction.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case transaction.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case transaction.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, transaction.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transaction.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Transaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Transaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionMutation) ResetField(name string) error {
	switch name {
	case transaction.FieldDate:
		m.ResetDate()
		return nil
	case transaction.FieldAmount:
		m.ResetAmount()
		return nil
	case transaction.FieldName:
		m.ResetName()
		return nil
	case transaction.FieldLocation:
		m.ResetLocation()
		return nil
	case transaction.FieldCategory:
		m.ResetCategory()
		return nil
	case transaction.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Transaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transaction edge %s", name)
}
